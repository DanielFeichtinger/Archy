# forms.py
# The Raskin Center for Humane Interfaces (RCHI) 2004-2005

import  commands, behavior_editing
from archy_state import archyState

class AddFormCommand(commands.CommandObject):
    def __init__(self):
        #It may seem redundant to keep an items list which could
# easily be generated by self.inputs.keys(). However, the resultant list
# does not preserve order. I use the self.items list to preserve order.
        self.items = []
        self.inputs = {}
        self.acceptable_values = {}
        self.mapped_values = {}
        self.multi_line = {}
        self.password = {}

        self.history = []
        self.border_string = ''

    def create(self, field, input='', acceptable_values = [], mapped_values = [], multiline = 0, password = 0):
        self.items.append(field)
        self.inputs[field] = input
        self.acceptable_values[field] = acceptable_values
        self.mapped_values[field] = mapped_values
        self.multi_line[field] = multiline
        self.password[field] = password

    def border(self, char):
        self.border_string = char

    def text(self):
        text = ''
        text += self.border_string
        for item in self.items:
            if self.acceptable_values[item]:
                text += '%s [%s]: %s\n' % (item, '/'.join(self.acceptable_values[item]), self.inputs[item])
            else:
                text += '%s: %s\n' % (item, self.inputs[item])
        text += self.border_string
        return text

    def execute(self):
        text = self.text()

        cmd = archyState.commandMap.findSystemCommand('AddText')
        cmd.setinfo(text)
        self.history.append(cmd)
        
        self.history.append(archyState.commandMap.findSystemCommand('CreepLeft'))
        self.history.append(archyState.commandMap.findSystemCommand('CreepLeft'))

        for item in self.items:
            cmd = archyState.commandMap.findSystemCommand('LEAP forward to:')
            cmd.setinfo(item)
            self.history.append(cmd)
            cmd = archyState.commandMap.findSystemCommand('LEAP forward to:')
            cmd.setinfo(':')
            self.history.append(cmd)
            
            self.history.append(archyState.commandMap.findSystemCommand('Select') )
            self.history.append(archyState.commandMap.findSystemCommand('Form Lock') )
            cmd = archyState.commandMap.findSystemCommand('LEAP forward to:')
            cmd.setinfo('\n')
            self.history.append(cmd)
            self.history.append(archyState.commandMap.findSystemCommand('LOCK') )

        if self.border_string <> '':
            cmd = archyState.commandMap.findSystemCommand('LEAP backward to:')
            cmd.setinfo(self.border_string)
            self.history.append(cmd)
            self.history.append(archyState.commandMap.findSystemCommand('LOCK') )
            cmd = archyState.commandMap.findSystemCommand('LEAP forward to:')
            cmd.setinfo(self.border_string)
            self.history.append(cmd)
            self.history.append(archyState.commandMap.findSystemCommand('LOCK') )

        for item in range(len(self.items)+1):
            self.history.append(archyState.commandMap.findSystemCommand("DROP"))
        self.history.pop()

        for com in self.history:
            com.execute()

    def undo(self):
        self.history.reverse()
        for com in self.history:
            com.undo()

    def parse(self, text, text_pos = None):
        field_pos = 0
        
        for i in range(len(self.items)):
            field = self.items[i]
            next_field = self.items[ (i+1) % len(self.items)]
            
            field_pos = text.find(field, field_pos)

            if self.multi_line[field] == 1:
                next_field_pos = text.find('\n'+next_field, field_pos)
                border_pos = text.find(self.border_string, field_pos)

                if border_pos < 0: border_pos = len(text)
                if next_field_pos < 0: next_field_pos = len(text)

                next_field_pos = min(border_pos, next_field_pos)
            else:
                next_field_pos = text.find('\n', field_pos+1)
                
            line = text[field_pos:next_field_pos].strip()
            
            if line.count(':') < 1: continue
            first_colon = line.find(':')
            input = None
            if self.password[field] == 1:
                asterix_pos = text.find('*', first_colon+field_pos)
                if asterix_pos > 0:
                    storage = archyState.mainText.behaviorArray.getStorage("PASSWORD", text_pos+asterix_pos)
                    if storage <> None:
                        input = storage.getPassword()
            
            if input == None:
                input = line[first_colon+1:]
                input = input.strip()

            if input in self.acceptable_values[field] or len(self.acceptable_values[field]) < 1:
                if len(self.mapped_values[field]) > 0:
                    self[field] = self.mapped_values[field][self.acceptable_values[field].index(input)]
                else:
                    self[field] = input
            else:
                print "Incorrect input"+ input


    def toDict(self):
        return self.inputs

    def keys(self):
        return self.items

    def __setitem__(self, item, input):
        if item in self.items:
            self.inputs[item] = input
        else:
            raise "No such form field", item

    def __getitem__(self, item):
        if item in self.items:
            return self.inputs[item]
        else:
            return None

class PasswordStorage:
    def __init__(self):
        self.p = ''

    def behaviorName(self):
        return "PASSWORD"

    def setPassword(self, passw):
        self.p = passw
    
    def getPassword(self):
        return self.p



class PasswordLockCommand(commands.CommandObject):
    def name(self):
        return "HIDE PASSWORD"

    def execute(self):
        mT = archyState.mainText
        selRange = mT.getSelection('selection')
        text, style = mT.getStyledText(*selRange)
        
        import behavior
        storage = PasswordStorage()
        storage.setPassword(text)
        mT.behaviorArray.setStorage("PASSWORD", storage)

        self.delText = archyState.commandMap.findSystemCommand("DeleteText")
        self.addText = archyState.commandMap.findSystemCommand("AddText")
        self.addText.setinfo(len(text)*'*')
        self.theAction = behavior_editing.AddActionCommand("PASSWORD")

        self.delText.execute()
        self.addText.execute()
        self.theAction.execute()
    
    def undo(self):
        pass
        
        

COMMANDS = [PasswordLockCommand]
BEHAVIORS = [ {'name':"PASSWORD"} ]


